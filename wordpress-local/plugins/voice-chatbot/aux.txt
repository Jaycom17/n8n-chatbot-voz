document.addEventListener("DOMContentLoaded", () => {
  const button = document.getElementById("voice-btn");
  const mainStatus = document.querySelector(".main-status");
  const subStatus = document.querySelector(".sub-status");
  const botAudio = document.getElementById("bot-audio");
  const chatMessages = document.getElementById("chat-messages");
  const statusIndicator = document.getElementById("status-indicator");
  const container = document.getElementById("voice-chatbot-container");

  // Verificar configuraci√≥na
  if (!voiceChatbotConfig.hasConfig) {
    container.innerHTML = `
      <div style="padding: 2rem; text-align: center; color: #ef4444;">
        <h3>‚ö†Ô∏è Configuraci√≥n Requerida</h3>
        <p>Por favor configura el plugin en:<br><strong>Ajustes ‚Üí Voice Chatbot</strong></p>
      </div>
    `;
    return;
  }

  if (!voiceChatbotConfig.jwtToken) {
    console.error("‚ùå No se pudo generar el token JWT");
    alert("Error: No se pudo generar el token de autenticaci√≥n. Verifica la configuraci√≥n del secreto JWT.");
    return;
  }

  let mediaRecorder;
  let audioChunks = [];
  let isRecording = false;
  let isProcessing = false;
  let isPlaying = false;

  // Estados del chatbot
  const States = {
    READY: "ready",
    LISTENING: "listening",
    PROCESSING: "processing",
    SPEAKING: "speaking"
  };

  let currentState = States.READY;

  // Cambiar estado visual
  function setState(state) {
    currentState = state;
    button.className = state;
    container.className = state;

    switch (state) {
      case States.READY:
        mainStatus.textContent = "Listo para escuchar";
        subStatus.textContent = "Presiona el bot√≥n para hablar";
        statusIndicator.className = "";
        break;
      case States.LISTENING:
        mainStatus.textContent = "Escuchando...";
        subStatus.textContent = "Habla ahora, presiona de nuevo para enviar";
        statusIndicator.className = "listening";
        break;
      case States.PROCESSING:
        mainStatus.textContent = "Procesando tu mensaje";
        subStatus.textContent = "El asistente est√° pensando...";
        statusIndicator.className = "processing";
        break;
      case States.SPEAKING:
        mainStatus.textContent = "Asistente hablando";
        subStatus.textContent = "Presiona para interrumpir y hablar";
        statusIndicator.className = "speaking";
        break;
    }
  }

  // Agregar mensaje al chat
  function addMessage(text, type) {
    const messageDiv = document.createElement("div");
    messageDiv.className = `chat-message ${type}`;
    
    const icon = document.createElement("div");
    icon.className = "message-icon";
    icon.innerHTML = type === "user" 
      ? '<svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>'
      : '<svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/></svg>';
    
    const content = document.createElement("div");
    content.className = "message-content";
    content.textContent = text;
    
    const timestamp = document.createElement("div");
    timestamp.className = "message-time";
    timestamp.textContent = new Date().toLocaleTimeString("es-ES", { 
      hour: "2-digit", 
      minute: "2-digit" 
    });
    
    messageDiv.appendChild(icon);
    messageDiv.appendChild(content);
    messageDiv.appendChild(timestamp);
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  // Iniciar grabaci√≥n
  async function startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          audioChunks.push(e.data);
        }
      };

      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
        audioChunks = [];
        
        // Detener el stream
        stream.getTracks().forEach(track => track.stop());
        
        await sendAudioToWebhook(audioBlob);
      };

      mediaRecorder.start();
      isRecording = true;
      setState(States.LISTENING);
      
      addMessage("Mensaje de voz enviado", "user");
      
    } catch (err) {
      console.error("Error al acceder al micr√≥fono:", err);
      alert("‚ùå No se pudo acceder al micr√≥fono. Por favor, permite el acceso.");
      setState(States.READY);
    }
  }

  // Detener grabaci√≥n
  function stopRecording() {
    if (mediaRecorder && isRecording) {
      mediaRecorder.stop();
      isRecording = false;
    }
  }

  // Enviar audio al webhook con JWT en el header
  async function sendAudioToWebhook(audioBlob) {
    setState(States.PROCESSING);

    const formData = new FormData();
    formData.append("file", audioBlob, "audio.webm");

    try {
      const response = await fetch(voiceChatbotConfig.webhookUrl, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${voiceChatbotConfig.jwtToken}`
        },
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`Error del servidor: ${response.status}`);
      }

      const data = await response.json();

      if (data.audioUrl) {
        playBotResponse(data.audioUrl);
        addMessage("Respuesta del asistente", "bot");
      } else {
        throw new Error("No se recibi√≥ URL de audio en la respuesta");
      }
      
    } catch (err) {
      console.error("Error al procesar la solicitud:", err);
      alert("‚ùå Error al comunicarse con el asistente. Intenta de nuevo.");
      setState(States.READY);
    }
  }

  // Reproducir respuesta del bot
  function playBotResponse(audioUrl) {
    setState(States.SPEAKING);
    
    botAudio.src = audioUrl;
    botAudio.load();
    
    botAudio.oncanplaythrough = () => {
      botAudio.play().catch(err => {
        console.error("Error al reproducir audio:", err);
        alert("‚ùå Error al reproducir la respuesta.");
        setState(States.READY);
      });
    };
    
    botAudio.onended = () => {
      setState(States.READY);
      isPlaying = false;
    };
    
    botAudio.onerror = () => {
      console.error("Error al cargar el audio");
      alert("‚ùå Error al cargar la respuesta de audio.");
      setState(States.READY);
    };
    
    isPlaying = true;
  }

  // Interrumpir reproducci√≥n
  function stopPlayback() {
    if (botAudio && !botAudio.paused) {
      botAudio.pause();
      botAudio.currentTime = 0;
      isPlaying = false;
    }
  }

  // Manejador del bot√≥n principal
  button.addEventListener("click", () => {
    switch (currentState) {
      case States.READY:
        // Iniciar grabaci√≥n
        startRecording();
        break;
        
      case States.LISTENING:
        // Detener y enviar
        stopRecording();
        break;
        
      case States.SPEAKING:
        // Interrumpir y empezar a grabar
        stopPlayback();
        startRecording();
        break;
        
      case States.PROCESSING:
        // No hacer nada mientras procesa
        break;
    }
  });

  // Inicializar
  setState(States.READY);
  
  console.log("üéôÔ∏è Voice Chatbot inicializado correctamente");
  console.log("üîê JWT Token configurado");
});

  // Cambiar estado visual
  function setState(state) {
    currentState = state;
    button.className = state;
    container.className = state;

    switch (state) {
      case States.READY:
        mainStatus.textContent = "Listo para escuchar";
        subStatus.textContent = "Presiona el bot√≥n para hablar";
        statusIndicator.className = "";
        break;
      case States.LISTENING:
        mainStatus.textContent = "Escuchando...";
        subStatus.textContent = "Habla ahora, presiona de nuevo para enviar";
        statusIndicator.className = "listening";
        break;
      case States.PROCESSING:
        mainStatus.textContent = "Procesando tu mensaje";
        subStatus.textContent = "El asistente est√° pensando...";
        statusIndicator.className = "processing";
        break;
      case States.SPEAKING:
        mainStatus.textContent = "Asistente hablando";
        subStatus.textContent = "Presiona para interrumpir y hablar";
        statusIndicator.className = "speaking";
        break;
    }
  }

  // Agregar mensaje al chat
  function addMessage(text, type) {
    const messageDiv = document.createElement("div");
    messageDiv.className = `chat-message ${type}`;
    
    const icon = document.createElement("div");
    icon.className = "message-icon";
    icon.innerHTML = type === "user" 
      ? '<svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>'
      : '<svg viewBox="0 0 24 24" width="20" height="20"><path fill="currentColor" d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/></svg>';
    
    const content = document.createElement("div");
    content.className = "message-content";
    content.textContent = text;
    
    const timestamp = document.createElement("div");
    timestamp.className = "message-time";
    timestamp.textContent = new Date().toLocaleTimeString("es-ES", { 
      hour: "2-digit", 
      minute: "2-digit" 
    });
    
    messageDiv.appendChild(icon);
    messageDiv.appendChild(content);
    messageDiv.appendChild(timestamp);
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  // Iniciar grabaci√≥n
  async function startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          audioChunks.push(e.data);
        }
      };

      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
        audioChunks = [];
        
        // Detener el stream
        stream.getTracks().forEach(track => track.stop());
        
        await sendAudioToWebhook(audioBlob);
      };

      mediaRecorder.start();
      isRecording = true;
      setState(States.LISTENING);
      
      addMessage("Mensaje de voz enviado", "user");
      
    } catch (err) {
      console.error("Error al acceder al micr√≥fono:", err);
      alert("‚ùå No se pudo acceder al micr√≥fono. Por favor, permite el acceso.");
      setState(States.READY);
    }
  }

  // Detener grabaci√≥n
  function stopRecording() {
    if (mediaRecorder && isRecording) {
      mediaRecorder.stop();
      isRecording = false;
    }
  }

  // Enviar audio al webhook
  async function sendAudioToWebhook(audioBlob) {
    setState(States.PROCESSING);

    const formData = new FormData();
    formData.append("file", audioBlob, "audio.webm");

    try {
      const response = await fetch(voiceChatbotConfig.webhookUrl, {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`Error del servidor: ${response.status}`);
      }

      const data = await response.json();

      if (data.audioUrl) {
        playBotResponse(data.audioUrl);
        addMessage("Respuesta del asistente", "bot");
      } else {
        throw new Error("No se recibi√≥ URL de audio en la respuesta");
      }
      
    } catch (err) {
      console.error("Error al procesar la solicitud:", err);
      alert("‚ùå Error al comunicarse con el asistente. Intenta de nuevo.");
      setState(States.READY);
    }
  }

  // Reproducir respuesta del bot
  function playBotResponse(audioUrl) {
    setState(States.SPEAKING);
    
    botAudio.src = audioUrl;
    botAudio.load();
    
    botAudio.oncanplaythrough = () => {
      botAudio.play().catch(err => {
        console.error("Error al reproducir audio:", err);
        alert("‚ùå Error al reproducir la respuesta.");
        setState(States.READY);
      });
    };
    
    botAudio.onended = () => {
      setState(States.READY);
      isPlaying = false;
    };
    
    botAudio.onerror = () => {
      console.error("Error al cargar el audio");
      alert("‚ùå Error al cargar la respuesta de audio.");
      setState(States.READY);
    };
    
    isPlaying = true;
  }

  // Interrumpir reproducci√≥n
  function stopPlayback() {
    if (botAudio && !botAudio.paused) {
      botAudio.pause();
      botAudio.currentTime = 0;
      isPlaying = false;
    }
  }

  // Manejador del bot√≥n principal
  button.addEventListener("click", () => {
    switch (currentState) {
      case States.READY:
        // Iniciar grabaci√≥n
        startRecording();
        break;
        
      case States.LISTENING:
        // Detener y enviar
        stopRecording();
        break;
        
      case States.SPEAKING:
        // Interrumpir y empezar a grabar
        stopPlayback();
        startRecording();
        break;
        
      case States.PROCESSING:
        // No hacer nada mientras procesa
        break;
    }
  });

  // Inicializar
  setState(States.READY);
  
  console.log("üéôÔ∏è Voice Chatbot inicializado correctamente");
});
